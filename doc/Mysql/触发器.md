## 触发器
```
SQL触发器是存储在数据库目录中的一组SQL语句。每当与表相关联的事件发生时，即会执行或触发SQL触发器，例如插入，更新或删除。
```

#### 优劣分析(摘自https://blog.csdn.net/jesse621/article/details/9452049)

- 触发器是特殊的存储过程。
    - 它不需要参数，不需要显示调用，在不知情的情况下已经做了很多操作
    - 无形中增加了系统的复杂性，非DBA人员理解起来数据库就会有困难
    - 涉及到复杂的逻辑的时候，触发器嵌套，涉及几个存储过程，再加上事务，很容易出现死锁，再调试的时候也会经常性的从一个触发器转到另外一个，级联关系的不断追溯，很容易使人头大。
    - 结论:从性能上，触发器并没有提升多少性能，只是从代码上来说，可能在coding的时候很容易实现业务，所以我的观点是：摒弃触发器！触发器的功能基本都可以用存储过程来实现。

- 存储过程优点很多，可以经常使用
    - 可以封装数据逻辑和业务规则，以便用户可以仅通过开发人员和数据库管理员打算使用的方式访问数据和对象。
    - 验证所有用户输入的参数化存储过程可用于阻止 SQL 注入攻击。 如果使用动态 SQL，请确保将命令参数化，并绝对不能将参数值直接包括在查询字符串中。
    - 可禁止即席查询和数据修改。 这样将阻止用户恶意或无意中损坏数据或执行查询，以避免降低服务器或网络的性能。
    - 可以在过程代码中处理错误，而无需将错误直接传递给客户端应用程序。 这样可防止返回错误消息，以避免其可能有助于探测攻击。 在服务器上记录错误并对其进行处理。
    - 存储过程只能编写一次，可由很多应用程序访问。
    - 客户端应用程序不需要知道有关基础数据结构的任何信息。 只要更改不影响参数列表或返回的数据类型，就可以更改存储过程代码，而无需在客户端应用程序中进行更改。
    - 存储过程可通过将多个操作组合到一个过程调用中来减少网络通讯。
    - 安全性好—可以访问执行存储过程而不必拥有直接操作基础表的权限
    - 减少网络通信流—存储过程可以包含多条SQL语句，但只要用一条语句来执行该存储过程，从而减少了客户端应用程序对服务器的调用次数和长度
    - 快速执行—存储过程在第一次执行时进行语法检查和编译，编译好的版本存储在高速缓存中，用于再次调用
    - 保证一致性—如果用户只通过存储过程修改数据，则可以消除偶然修改带来的问题减少操作人员和编程人员的错误—由于传递信息少，因此执行复杂任务更容易，不易出现SQL错误
    
- 考虑移植性，存储过程的致命伤
    - 如果数据量很小，几十年用sql-server都没问题,那就可以多用存储过程;但是数据量有可能会逐渐累积成千万条甚至更多,就不得不考虑系统的可移植性，这时候尽量不要用存储过程，全部代码控制.
    
- 存储过程的代码可复用性差
    - 面向对象的思维在存储过程这毫无用武之地，两个很相似的功能在也需要两个存储过程，因为他们是互相独立的，可以互相调用，但是不能继承等面向对象的操作，这也就增加了代码量.

#### 触发器操作

##### 查看所有触发器
- show TRIGGERS;

#### 删除触发器
- drop trigger [IF EXISTS] triggre_name;

##### 创建一条触发器

```$xslt
DROP TRIGGER IF EXISTS trigger_user;

CREATE TRIGGER 
    trigger_user 
AFTER INSERT ON 
    test_user 
FOR EACH ROW
BEGIN
	INSERT INTO test_log (
		model,
		sub_model,
		user_id,
		operation,
		is_status,
		description
	)VALUES(
		'1111',
		'22222',
		152,
		'add',
		'Y',
		'哈哈哈哈或'
	);
END;
```
